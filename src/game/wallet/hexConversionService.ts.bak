/**
 * HEX Token Conversion Service
 * 
 * Maneja la conversi√≥n de Faith a HEX mediante el contrato hex_token desplegado
 * Integra con OneWallet para firmar transacciones en OneChain
 */

import { Transaction } from '@onelabs/sui/transactions';
import { bcs } from '@onelabs/sui/bcs';
import { onechainClient } from './onechainClient';
import { getCurrentAccount, isWalletConnected, getWalletInstance } from './walletConfig';
import { ONECHAIN_PACKAGE_ID, HEX_TOKEN, CONVERSION_RATES, NETWORK_CONFIG } from '../../config/contracts';

/**
 * Resultado de la conversi√≥n
 */
export interface ConversionResult {
  success: boolean;
  faithSpent?: number;
  hexReceived?: number;
  transactionDigest?: string;
  error?: string;
}

/**
 * Estado de la transacci√≥n
 */
export type TransactionStatus = 
  | 'idle'
  | 'connecting-wallet'
  | 'building-transaction'
  | 'signing'
  | 'executing'
  | 'confirming'
  | 'success'
  | 'error';

/**
 * Calcula cu√°nto HEX se recibir√° por una cantidad de Faith
 */
export function calculateHexAmount(faithAmount: number): number {
  return Math.floor(faithAmount / CONVERSION_RATES.FAITH_TO_HEX);
}

/**
 * Valida que la cantidad de Faith sea v√°lida para conversi√≥n
 */
export function validateFaithAmount(faithAmount: number): { valid: boolean; error?: string } {
  if (faithAmount <= 0) {
    return { valid: false, error: 'No hay Faith disponible para convertir' };
  }
  
  if (faithAmount < CONVERSION_RATES.FAITH_TO_HEX) {
    return { 
      valid: false, 
      error: `Necesitas al menos ${CONVERSION_RATES.FAITH_TO_HEX} Faith para convertir` 
    };
  }
  
  return { valid: true };
}

/**
 * Convierte Faith a HEX llamando al contrato hex_token::mint_from_faith
 * 
 * @param faithAmount - Cantidad de Faith a convertir
 * @param onStatusChange - Callback para actualizar el estado de la transacci√≥n
 * @returns Resultado de la conversi√≥n
 */
export async function convertFaithToHex(
  faithAmount: number,
  onStatusChange?: (status: TransactionStatus, message?: string) => void
): Promise<ConversionResult> {
  try {
    // Validar Faith
    const validation = validateFaithAmount(faithAmount);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.error,
      };
    }

    // Verificar que la wallet est√© conectada
    onStatusChange?.('connecting-wallet', 'Verificando conexi√≥n de wallet...');
    if (!isWalletConnected()) {
      return {
        success: false,
        error: 'Wallet no conectada. Por favor, conecta tu OneWallet primero.',
      };
    }

    const account = getCurrentAccount();
    if (!account || !account.address) {
      return {
        success: false,
        error: 'No se pudo obtener la cuenta de la wallet.',
      };
    }

    // CR√çTICO: Verificar que la wallet est√© en Testnet
    console.log('üîç Verificando red de la wallet...');
    console.log('   Cuenta:', account.address);
    
    // Intentar obtener balance en Testnet para verificar conexi√≥n
    try {
      const testnetBalance = await onechainClient.getBalance({
        owner: account.address,
        coinType: '0x2::oct::OCT',
      });
      
      const octBalance = Number(testnetBalance.totalBalance) / 1_000_000_000;
      console.log('‚úÖ Conexi√≥n a Testnet verificada');
      console.log('   Balance en Testnet:', octBalance, 'OCT');
      
      if (octBalance < 0.1) {
        return {
          success: false,
          error: `Balance insuficiente en Testnet: ${octBalance.toFixed(4)} OCT. Necesitas al menos 0.1 OCT.\n\n‚ö†Ô∏è IMPORTANTE: Aseg√∫rate de que OneWallet est√© conectada a TESTNET, no a Mainnet.\n\nPara cambiar de red en OneWallet:\n1. Abre OneWallet\n2. Haz clic en el selector de red (arriba)\n3. Selecciona "Testnet"\n4. Recarga la p√°gina`,
        };
      }
    } catch (error: any) {
      console.error('‚ùå Error verificando red:', error);
      return {
        success: false,
        error: `No se pudo conectar a OneChain Testnet. \n\n‚ö†Ô∏è IMPORTANTE: Verifica que OneWallet est√© conectada a TESTNET, no a Mainnet.\n\nPara cambiar de red en OneWallet:\n1. Abre OneWallet\n2. Haz clic en el selector de red (arriba)\n3. Selecciona "Testnet"\n4. Recarga la p√°gina\n\nError t√©cnico: ${error.message}`,
      };
    }

    // Calcular HEX a recibir
    const hexAmount = calculateHexAmount(faithAmount);
    
    // Construir transacci√≥n
    onStatusChange?.('building-transaction', `Preparando conversi√≥n de ${faithAmount} Faith a ${hexAmount} HEX...`);
    
    console.log('üìû Construyendo transacci√≥n para conversi√≥n de Faith a HEX...');
    console.log('   Package:', ONECHAIN_PACKAGE_ID);
    console.log('   Module:', HEX_TOKEN.MODULE);
    console.log('   Function: mint_from_faith_public');
    console.log('   Faith amount:', faithAmount);
    console.log('   Conversion rate:', CONVERSION_RATES.FAITH_TO_HEX);
    console.log('   Expected HEX:', hexAmount);
    
    // Crear la transacci√≥n usando PTB (Programmable Transaction Block)
    const tx = new Transaction();
    
    // Configurar sender primero (requerido para objetos compartidos)
    tx.setSender(account.address);
    
    // IMPORTANTE: Seg√∫n la documentaci√≥n de OneChain, para valores puros (u64)
    // se debe usar tx.pure() directamente, que maneja la serializaci√≥n BCS autom√°ticamente
    // NO necesitamos serializar manualmente con bcs.u64().serialize()
    tx.moveCall({
      target: `${ONECHAIN_PACKAGE_ID}::${HEX_TOKEN.MODULE}::mint_from_faith_public`,
      arguments: [
        // holder: &mut TreasuryCapHolder (shared object)
        tx.object(HEX_TOKEN.TREASURY_HOLDER),
        
        // stats: &mut EconomyStats (shared object)  
        tx.object(HEX_TOKEN.ECONOMY_STATS),
        
        // faith_amount: u64 (pure value)
        // tx.pure() maneja autom√°ticamente la serializaci√≥n BCS seg√∫n el tipo
        tx.pure.u64(faithAmount),
        
        // conversion_rate: u64 (pure value)
        tx.pure.u64(CONVERSION_RATES.FAITH_TO_HEX),
        
        // ctx: &mut TxContext <- El sistema lo inyecta autom√°ticamente, NO se pasa
      ],
    });
    
    console.log('‚úÖ Transacci√≥n PTB construida correctamente');

    // Firmar y ejecutar transacci√≥n usando Wallet Standard
    onStatusChange?.('signing', 'Esperando firma de la wallet...');
    
    // Obtener wallet del sistema
    const wallet = getWalletInstance();
    
    if (!wallet) {
      return {
        success: false,
        error: 'OneWallet no est√° disponible',
      };
    }

    // Verificar que la wallet soporta la feature necesaria
    const signAndExecuteFeature = wallet.features['sui:signAndExecuteTransactionBlock'] as any;
    
    if (!signAndExecuteFeature) {
      return {
        success: false,
        error: 'La wallet no soporta signAndExecuteTransactionBlock',
      };
    }

    console.log('üìù Enviando transacci√≥n a OneWallet para firma y ejecuci√≥n...');
    
    // CR√çTICO: Construir y serializar la transacci√≥n ANTES de enviar a la wallet
    // Esto resuelve los "UnresolvedObject" a objetos completos con versiones
    console.log('üîß Construyendo transacci√≥n (bytes de respaldo) con el cliente OneChain...');
    let txBytes: Uint8Array | null = null;
    
    try {
      txBytes = await tx.build({ client: onechainClient });
      console.log('‚úÖ Transacci√≥n construida y serializada');
      console.log('   Tama√±o:', txBytes.length, 'bytes');
    } catch (error: any) {
      console.warn('‚ö†Ô∏è No se pudo construir bytes de respaldo:', error.message);
    }
    
    // Intentar con diferentes chain IDs porque OneWallet puede usar diferentes formatos.
    // Preferimos los que contengan "testnet" y luego a√±adimos variantes conocidas.
    const chainIdsToTry = Array.from(new Set([
      ...(account.chains ?? []).filter(c => c.toLowerCase().includes('testnet')),
      NETWORK_CONFIG.CHAIN_ID_ONECHAIN,
      NETWORK_CONFIG.CHAIN_ID_ALT,
      NETWORK_CONFIG.CHAIN_ID,
      'sui:testnet',
      'testnet',
    ].filter(Boolean)));
    
    let lastError: any = null;
    
    for (const chainId of chainIdsToTry) {
      try {
        console.log(`üîÑ Intentando firmar con chain ID: "${chainId}"`);
        
        // Primer intento: Transaction vivo (evita problemas de formato en algunas wallets)
        onStatusChange?.('executing', 'Ejecutando transacci√≥n en OneChain...');
        
        const result = await signAndExecuteFeature.signAndExecuteTransactionBlock({
          transactionBlock: tx,
          account: account,
          chain: chainId,
          options: {
            showEffects: true,
            showEvents: true,
            showObjectChanges: true,
          },
        });
        
        console.log(`‚úÖ Transacci√≥n ejecutada exitosamente con chain ID: "${chainId}"`);
        console.log('   Digest:', result.digest);

        // Esperar confirmaci√≥n
        onStatusChange?.('confirming', 'Confirmando transacci√≥n...');
        
        if (!result || !result.digest) {
          return {
            success: false,
            error: 'La transacci√≥n no retorn√≥ un digest v√°lido',
          };
        }

        // Verificar el resultado
        const txResponse = await onechainClient.waitForTransaction({
          digest: result.digest,
          options: {
            showEffects: true,
            showEvents: true,
          },
        });

        // Verificar si la transacci√≥n fue exitosa
        if (txResponse.effects?.status?.status !== 'success') {
          return {
            success: false,
            error: `Transacci√≥n fallida: ${txResponse.effects?.status?.error || 'Error desconocido'}`,
          };
        }

        onStatusChange?.('success', `¬°Conversi√≥n exitosa! ${hexAmount} HEX recibidos`);

        return {
          success: true,
          faithSpent: faithAmount,
          hexReceived: hexAmount,
          transactionDigest: result.digest,
        };
      } catch (error: any) {
        console.warn(`‚ö†Ô∏è Intento con chain ID "${chainId}" fall√≥:`, error.message);
        // Si la wallet se queja del formato, intentamos de nuevo con bytes/base64.
        if (error?.message?.toLowerCase().includes('transaction format') && txBytes) {
          try {
            console.log(`üîÅ Reintentando con bytes en chain ID: "${chainId}"`);
            const result = await signAndExecuteFeature.signAndExecuteTransactionBlock({
              transactionBlock: Buffer.from(txBytes).toString('base64'),
              account: account,
              chain: chainId,
              options: {
                showEffects: true,
                showEvents: true,
                showObjectChanges: true,
              },
            });

            console.log(`‚úÖ Transacci√≥n ejecutada exitosamente con chain ID: "${chainId}" (bytes)`);
            console.log('   Digest:', result.digest);

            onStatusChange?.('confirming', 'Confirmando transacci√≥n...');
            
            if (!result || !result.digest) {
              return {
                success: false,
                error: 'La transacci√≥n no retorn√≥ un digest v√°lido',
              };
            }

            const txResponse = await onechainClient.waitForTransaction({
              digest: result.digest,
              options: {
                showEffects: true,
                showEvents: true,
              },
            });

            if (txResponse.effects?.status?.status !== 'success') {
              return {
                success: false,
                error: `Transacci√≥n fallida: ${txResponse.effects?.status?.error || 'Error desconocido'}`,
              };
            }

            onStatusChange?.('success', `¬°Conversi√≥n exitosa! ${hexAmount} HEX recibidos`);

            return {
              success: true,
              faithSpent: faithAmount,
              hexReceived: hexAmount,
              transactionDigest: result.digest,
            };
          } catch (fallbackError: any) {
            console.warn(`‚ö†Ô∏è Reintento con bytes fall√≥:`, fallbackError.message);
          }
        }
        lastError = error;
        // Continuar con el siguiente chain ID
        continue;
      }
    }
    
    // Si llegamos aqu√≠, todos los intentos fallaron
    console.error('‚ùå Todos los intentos de firma fallaron');
    console.error('   √öltimo error:', lastError);
    
    // Si llegamos aqu√≠, todos los intentos fallaron
    console.error('‚ùå Todos los intentos de firma fallaron');
    console.error('   √öltimo error:', lastError);
    
    // Verificar si el error es por red incorrecta
    const errorMsg = lastError?.message || '';
    const isNetworkError = errorMsg.includes('network') || errorMsg.includes('endpoint') || errorMsg.includes('chain') || errorMsg.includes('failed');
    
    return {
      success: false,
      error: `Error ejecutando transacci√≥n: ${lastError?.message || 'Error desconocido'}\n\n${
        isNetworkError 
          ? '‚ö†Ô∏è PROBLEMA DE RED DETECTADO\n\nOneWallet parece estar conectada a la red incorrecta.\n\nSOLUCI√ìN:\n1. Abre OneWallet\n2. Haz clic en el selector de red (parte superior)\n3. Selecciona "Testnet" (NO Mainnet)\n4. Recarga esta p√°gina\n5. Intenta de nuevo'
          : 'Aseg√∫rate de que OneWallet est√© conectada a OneChain Testnet.'
      }`,
    };
  } catch (error: any) {
    console.error('‚ùå Error general en convertFaithToHex:', error);
    return {
      success: false,
      error: error.message || 'Error al convertir Faith a HEX',
    };
  }
}

/**
 * Obtiene el balance de HEX tokens de una direcci√≥n
 */
export async function getHexBalance(address: string): Promise<number> {
  try {
    const balance = await onechainClient.getBalance({
      owner: address,
      coinType: HEX_TOKEN.TYPE,
    });
    
    // Convertir de unidades m√°s peque√±as a HEX (9 decimales)
    return Number(balance.totalBalance) / 1_000_000_000;
  } catch (error) {
    console.error('‚ùå Error obteniendo balance de HEX:', error);
    return 0;
  }
}

/**
 * Obtiene las estad√≠sticas del contrato HEX
 */
export async function getHexEconomyStats(): Promise<{
  totalMinted: number;
  totalBurned: number;
  faithConverted: number;
  circulatingSupply: number;
} | null> {
  try {
    const statsObject = await onechainClient.getObject({
      id: HEX_TOKEN.ECONOMY_STATS,
      options: {
        showContent: true,
      },
    });

    if (!statsObject.data || !statsObject.data.content || statsObject.data.content.dataType !== 'moveObject') {
      return null;
    }

    const fields = (statsObject.data.content as any).fields;
    
    return {
      totalMinted: Number(fields.total_minted) / 1_000_000_000,
      totalBurned: Number(fields.total_burned) / 1_000_000_000,
      faithConverted: Number(fields.faith_converted),
      circulatingSupply: (Number(fields.total_minted) - Number(fields.total_burned)) / 1_000_000_000,
    };
  } catch (error) {
    console.error('‚ùå Error obteniendo estad√≠sticas de HEX:', error);
    return null;
  }
}
